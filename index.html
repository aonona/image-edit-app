<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ダウンスケールでモザイク</title>
  <style>
    canvas {
      border: 1px solid black;
      touch-action: none; /* スマホでもドラッグ操作OK */
      cursor: crosshair;
    }
  </style>
</head>
<body>
<h1>ダウンスケールで部分モザイク</h1>
<p>PC・スマホ両対応、クリックドラッグした範囲を簡易モザイク。</p>

<input type="file" id="upload" accept="image/*"><br><br>
<canvas id="canvas"></canvas>
<button id="applyMosaic">モザイク</button>

<script>
const upload = document.getElementById('upload');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// 画像状態
let img = new Image();
let isImageLoaded = false;

// 選択範囲
let startX, startY, endX, endY;
let isSelecting = false;

// 画像データ管理
let editedImageData = null;

// ダウンスケールでモザイクする際の分割率
// 値が大きいほどモザイクが荒くなる。 10 → (1/10に縮小→10倍)
const mosaicFactor = 10;

upload.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      isImageLoaded = true;
      // 一旦編集後画像を保存
      editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

// Pointer Events: PC/スマホ兼用
canvas.addEventListener('pointerdown', e => {
  if (!isImageLoaded) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  startX = (e.clientX - rect.left)*scaleX;
  startY = (e.clientY - rect.top)*scaleY;
  isSelecting = true;
});
canvas.addEventListener('pointermove', e => {
  if (!isSelecting) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  endX = (e.clientX - rect.left)*scaleX;
  endY = (e.clientY - rect.top)*scaleY;
  drawSelection();
});
canvas.addEventListener('pointerup', e => {
  if (!isSelecting) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  endX = (e.clientX - rect.left)*scaleX;
  endY = (e.clientY - rect.top)*scaleY;
  isSelecting = false;
  drawSelection();
});
canvas.addEventListener('pointercancel', () => { isSelecting=false; });

function drawSelection(){
  // 編集後の画像を描き戻してから赤枠
  ctx.putImageData(editedImageData,0,0);
  if (startX===undefined || endX===undefined) return;
  ctx.strokeStyle='red';
  ctx.lineWidth=2;
  ctx.strokeRect(startX, startY, endX - startX, endY - startY);
}

// 部分モザイク: ダウンスケール→アップスケール
document.getElementById('applyMosaic').addEventListener('click', () => {
  if (!isImageLoaded || startX===undefined || endX===undefined) return;

  // 1) 赤枠なし画像へ戻す
  ctx.putImageData(editedImageData, 0, 0);

  // 2) 選択範囲を確定 (クランプ等は省略だが本当は必要)
  const x1 = Math.min(startX, endX);
  const y1 = Math.min(startY, endY);
  const w = Math.abs(endX - startX);
  const h = Math.abs(endY - startY);
  if (w<1 || h<1) return;

  // 3) 仮想キャンバスを作り、選択範囲をdrawImageで縮小描画
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = Math.max(1, Math.floor(w / mosaicFactor));
  tmpCanvas.height= Math.max(1, Math.floor(h / mosaicFactor));
  const tctx = tmpCanvas.getContext('2d');

  // 縮小描画（元画像の選択範囲を小さく貼り付け）
  tctx.drawImage(canvas, x1, y1, w, h, 0,0, tmpCanvas.width, tmpCanvas.height);

  // 4) その小さくなった画像を、再び元のサイズ(w,h)に拡大して書き戻す
  ctx.drawImage(tmpCanvas, 0,0, tmpCanvas.width, tmpCanvas.height, x1, y1, w, h);

  // 5) 新しい編集結果を保存
  editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // 必要なら選択枠を再描画
  drawSelection();
});
</script>
</body>
</html>
