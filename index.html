<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像編集アプリ v2.2</title>
    <style>
        canvas {
            border: 1px solid black;
            /* スマホやタブレットのスワイプ動作を防止して、自由にドラッグ操作できるようにする */
            touch-action: none;
            cursor: crosshair;
        }
        #controls {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>画像編集アプリ v2.2</h1>
    <!-- 画像をアップロード -->
    <input type="file" id="upload" accept="image/*">
    <br><br>
    
    <!-- 画像を描画するキャンバス -->
    <canvas id="canvas"></canvas>
    <div id="controls">
        <button id="applyMosaic">モザイク処理</button>
        <button id="applyTrim">トリミング</button>
        <button id="downloadImage">ダウンロード</button>
        <button id="undoButton">一個前に戻る</button>
        <button id="resetButton">リセット</button>
    </div>

    <script>
        // -------------------------------------------------
        // 要素の取得
        // -------------------------------------------------
        const uploadInput = document.getElementById('upload');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const applyMosaicBtn = document.getElementById('applyMosaic');
        const applyTrimBtn = document.getElementById('applyTrim');
        const downloadImageBtn = document.getElementById('downloadImage');
        const undoButton = document.getElementById('undoButton');
        const resetButton = document.getElementById('resetButton');

        // -------------------------------------------------
        // 画像関連の変数
        // -------------------------------------------------
        let img = new Image();
        let isImageLoaded = false;

        // -------------------------------------------------
        // 選択範囲・操作関連
        // -------------------------------------------------
        let startX, startY, endX, endY;
        let isSelecting = false;

        // -------------------------------------------------
        // 画像データ管理
        // -------------------------------------------------
        // 常に最新の「編集後の状態」を保持 (赤枠は含まない)
        let editedImageData = null;
        // リセット用に「オリジナル状態」を保持
        let originalImageData = null;
        // Undo用の履歴スタック (配列末尾が最新)
        let historyStack = [];

        // -------------------------------------------------
        // 画像アップロード処理
        // -------------------------------------------------
        uploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                img.onload = function() {
                    // キャンバスを画像サイズに合わせる
                    canvas.width = img.width;
                    canvas.height = img.height;

                    // 画像を描画
                    ctx.drawImage(img, 0, 0);
                    isImageLoaded = true;
                    
                    // 初期状態を保存
                    editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // 履歴スタックを初期化
                    historyStack = [];
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // -------------------------------------------------
        // Pointer Eventsによる操作 (PC & スマホ両対応)
        // -------------------------------------------------
        canvas.addEventListener('pointerdown', (event) => {
            if (!isImageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            // 見た目上の幅・高さに対して、実際のキャンバス解像度との比率
            const scaleX = canvas.width  / rect.width;
            const scaleY = canvas.height / rect.height;

            // スケールを考慮して座標を計算
            startX = (event.clientX - rect.left) * scaleX;
            startY = (event.clientY - rect.top)  * scaleY;
            
            isSelecting = true;
        });

        canvas.addEventListener('pointermove', (event) => {
            if (!isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width  / rect.width;
            const scaleY = canvas.height / rect.height;

            endX = (event.clientX - rect.left) * scaleX;
            endY = (event.clientY - rect.top)  * scaleY;
            
            drawSelection(); 
        });

        canvas.addEventListener('pointerup', (event) => {
            if (!isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width  / rect.width;
            const scaleY = canvas.height / rect.height;

            endX = (event.clientX - rect.left) * scaleX;
            endY = (event.clientY - rect.top)  * scaleY;
            
            isSelecting = false;
            drawSelection();
        });

        canvas.addEventListener('pointercancel', () => {
            isSelecting = false;
        });

        // -------------------------------------------------
        // 赤枠の描画関数
        // -------------------------------------------------
        function drawSelection() {
            if (!isImageLoaded) return;

            // まずは編集後の画像を再描画（赤枠なし）
            ctx.putImageData(editedImageData, 0, 0);

            // 選択範囲が確定していない場合は何もしない
            if (
                startX === undefined ||
                startY === undefined ||
                endX   === undefined ||
                endY   === undefined
            ) {
                return;
            }

            // 赤枠表示
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, startY, endX - startX, endY - startY);
        }

        // -------------------------------------------------
        // モザイク処理
        // -------------------------------------------------
        applyMosaicBtn.addEventListener('click', () => {
            if (!isImageLoaded || startX === undefined || endX === undefined) {
                return;
            }

            // 1. Undo用に現在のeditedImageDataを保存
            historyStack.push(editedImageData);

            // 2. 赤枠を消して元の編集状態に戻す
            ctx.putImageData(editedImageData, 0, 0);

            // 3. モザイクをかけるため、キャンバス全体のImageDataを取得
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const blockSize = 10;

            // 4. 選択範囲を確定し、キャンバス内にクランプ
            let startXInt = Math.min(startX, endX);
            let endXInt   = Math.max(startX, endX);
            let startYInt = Math.min(startY, endY);
            let endYInt   = Math.max(startY, endY);

            // 0未満やcanvasサイズ超過のときは修正
            startXInt = Math.max(0, Math.min(canvas.width,  startXInt));
            endXInt   = Math.max(0, Math.min(canvas.width,  endXInt));
            startYInt = Math.max(0, Math.min(canvas.height, startYInt));
            endYInt   = Math.max(0, Math.min(canvas.height, endYInt));

            // 5. 選択範囲内をブロック単位で塗りつぶし
            for (let y = startYInt; y < endYInt; y += blockSize) {
                for (let x = startXInt; x < endXInt; x += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    // ブロック内の平均色を計算
                    for (let dy = 0; dy < blockSize && (y + dy) < endYInt; dy++) {
                        for (let dx = 0; dx < blockSize && (x + dx) < endXInt; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            r += imageData.data[idx];
                            g += imageData.data[idx + 1];
                            b += imageData.data[idx + 2];
                            count++;
                        }
                    }
                    
                    const avgR = Math.floor(r / count);
                    const avgG = Math.floor(g / count);
                    const avgB = Math.floor(b / count);

                    // ブロック内のピクセルを平均色で塗り潰し
                    for (let dy = 0; dy < blockSize && (y + dy) < endYInt; dy++) {
                        for (let dx = 0; dx < blockSize && (x + dx) < endXInt; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            imageData.data[idx]     = avgR;
                            imageData.data[idx + 1] = avgG;
                            imageData.data[idx + 2] = avgB;
                        }
                    }
                }
            }

            // 6. モザイク結果を反映
            ctx.putImageData(imageData, 0, 0);

            // 7. editedImageDataを更新 (赤枠なし)
            editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // 8. 必要があれば赤枠を再表示
            drawSelection();
        });

        // -------------------------------------------------
        // トリミング処理
        // -------------------------------------------------
        applyTrimBtn.addEventListener('click', () => {
            if (!isImageLoaded ||
                startX === undefined || startY === undefined ||
                endX   === undefined || endY   === undefined
            ) {
                return;
            }

            // 1. Undo用に現在のeditedImageDataを保存
            historyStack.push(editedImageData);

            // 2. 赤枠を消して元の状態に戻す
            ctx.putImageData(editedImageData, 0, 0);

            // 3. トリミング範囲を確定し、キャンバス内にクランプ
            let trimX = Math.min(startX, endX);
            let trimY = Math.min(startY, endY);
            let trimWidth  = Math.abs(endX - startX);
            let trimHeight = Math.abs(endY - startY);

            // 0未満やcanvasサイズ超過のときは修正
            trimX = Math.max(0, Math.min(canvas.width,  trimX));
            trimY = Math.max(0, Math.min(canvas.height, trimY));

            // 幅・高さは、trimX / trimYを基点に超えないように再調整
            if (trimX + trimWidth  > canvas.width)  trimWidth  = canvas.width  - trimX;
            if (trimY + trimHeight > canvas.height) trimHeight = canvas.height - trimY;

            // 4. トリミング領域のImageDataを取得
            const trimmedData = ctx.getImageData(trimX, trimY, trimWidth, trimHeight);

            // 5. キャンバスサイズをトリミングした大きさに変更して配置
            canvas.width = trimWidth;
            canvas.height = trimHeight;
            ctx.putImageData(trimmedData, 0, 0);

            // 6. editedImageDataを更新
            editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // 7. 選択範囲をリセット
            startX = startY = endX = endY = undefined;
        });

        // -------------------------------------------------
        // ダウンロード処理
        // -------------------------------------------------
        downloadImageBtn.addEventListener('click', () => {
            if (!isImageLoaded) return;

            // 赤枠のないeditedImageDataを再描画
            ctx.putImageData(editedImageData, 0, 0);

            // ダウンロード用リンクを作成して実行
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        // -------------------------------------------------
        // 一個前に戻す (Undo)
        // -------------------------------------------------
        undoButton.addEventListener('click', () => {
            if (historyStack.length === 0) return; // 履歴がなければ何もしない
            
            // 1. スタックの最後を取り出して editedImageData に戻す
            editedImageData = historyStack.pop();

            // 2. キャンバスサイズも復元
            canvas.width = editedImageData.width;
            canvas.height = editedImageData.height;
            
            // 3. 再描画
            ctx.putImageData(editedImageData, 0, 0);

            // 4. 選択範囲もリセット
            startX = startY = endX = endY = undefined;
        });

        // -------------------------------------------------
        // リセット処理 (最初に戻す)
        // -------------------------------------------------
        resetButton.addEventListener('click', () => {
            if (!originalImageData) return;

            // originalImageData を現在の編集結果として復元
            editedImageData = originalImageData;

            // キャンバスサイズをオリジナルに
            canvas.width = originalImageData.width;
            canvas.height = originalImageData.height;

            // 再描画
            ctx.putImageData(originalImageData, 0, 0);

            // 履歴はクリア
            historyStack = [];

            // 選択範囲リセット
            startX = startY = endX = endY = undefined;
        });
    </script>
</body>
</html>
