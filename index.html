<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ダウンスケールモザイク+トリミング+Undo+リセット+DL</title>
  <style>
    canvas {
      border: 1px solid black;
      touch-action: none; /* スマホでもドラッグ操作 */
      cursor: crosshair;
    }
    #controls {
      margin-top: 10px;
    }
  </style>
</head>
<body>
<h1>ダウンスケール方式モザイク+トリミング+Undo+リセット+ダウンロード</h1>
<p>PC/スマホ対応。縮小→再拡大でブロック化してモザイクを実現。</p>

<!-- 画像アップロード -->
<input type="file" id="upload" accept="image/*"><br><br>
<canvas id="canvas"></canvas>

<div id="controls">
  <button id="applyMosaic">モザイク</button>
  <button id="applyTrim">トリミング</button>
  <button id="downloadBtn">ダウンロード</button>
  <button id="undoBtn">一つ戻る</button>
  <button id="resetBtn">リセット</button>
</div>

<script>
/* --------------------------------------------------
   1) 要素・変数の定義
-------------------------------------------------- */
const uploadInput = document.getElementById('upload');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const applyMosaicBtn = document.getElementById('applyMosaic');
const applyTrimBtn   = document.getElementById('applyTrim');
const downloadBtn    = document.getElementById('downloadBtn');
const undoBtn        = document.getElementById('undoBtn');
const resetBtn       = document.getElementById('resetBtn');

let img = new Image();
let isImageLoaded = false;

// 選択範囲
let startX, startY, endX, endY;
let isSelecting = false;

// ダウンスケールモザイクの“粗さ”を決める倍率。
// 値が大きいほど荒くなる。例:10 → 1/10に縮小後に再拡大
let mosaicFactor = 10;

/* 
  Undo用の履歴スタック:
    - canvasの幅・高さ・ImageData全部を保存
*/
let historyStack = [];

// リセット用に、読み込み直後のCanvas状態(オリジナル)を保持
let originalWidth  = 0;
let originalHeight = 0;
let originalImageData = null;

// --------------------------------------------------
// 2) 画像アップロード
// --------------------------------------------------
uploadInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = ev => {
    img.onload = () => {
      // キャンバスを画像サイズに合わせる
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      isImageLoaded = true;

      // リセット用に初期状態を保存
      originalWidth  = img.width;
      originalHeight = img.height;
      originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // 履歴スタックをクリア
      historyStack = [];
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

// --------------------------------------------------
// 3) Pointer Events で 範囲選択 (PC/スマホ対応)
// --------------------------------------------------
canvas.addEventListener('pointerdown', e => {
  if (!isImageLoaded) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height/ rect.height;

  startX = (e.clientX - rect.left) * scaleX;
  startY = (e.clientY - rect.top ) * scaleY;
  isSelecting = true;
});

canvas.addEventListener('pointermove', e => {
  if (!isSelecting) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height/ rect.height;

  endX = (e.clientX - rect.left) * scaleX;
  endY = (e.clientY - rect.top ) * scaleY;
  drawSelection();
});

canvas.addEventListener('pointerup', e => {
  if (!isSelecting) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height/ rect.height;

  endX = (e.clientX - rect.left) * scaleX;
  endY = (e.clientY - rect.top ) * scaleY;
  isSelecting = false;
  drawSelection();
});

canvas.addEventListener('pointercancel', () => {
  isSelecting = false;
});

// 選択枠を描画する関数
function drawSelection(){
  if (!isImageLoaded) return;
  // 現在キャンバスに入っている状態を改めて描画
  // (Undo後など何度も再描画の可能性がある)
  // → 実際には現行状態のImageDataを保持してもいいが、今回は何もしなくても
  //    現状のcanvas上に余計なものを描いてない前提なのでOK

  // clear→putImageDataするなら、モザイク後の状態を常に保持する必要があるが、
  // 今回はダウンスケールモザイク後にgetImageDataしていないので省略。
  // ひとまず redraw せずとも「画面には」現在の状態がある。

  if (startX===undefined || endX===undefined) return;

  // 赤枠を表示
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  ctx.strokeRect(
    startX, startY,
    (endX - startX),
    (endY - startY)
  );
}

// --------------------------------------------------
// 4) Undo用に現在のCanvasを保存する関数
// --------------------------------------------------
function pushHistory(){
  // ImageDataとキャンバスサイズ両方
  const snap = {
    width: canvas.width,
    height: canvas.height,
    data: ctx.getImageData(0, 0, canvas.width, canvas.height)
  };
  historyStack.push(snap);
}

// --------------------------------------------------
// 5) モザイク処理 (ダウンスケール→アップスケール手法)
// --------------------------------------------------
applyMosaicBtn.addEventListener('click', () => {
  if (!isImageLoaded) return;
  if (startX===undefined || endX===undefined) return;

  // Undo保存
  pushHistory();

  // 選択範囲を計算 (クランプなど省略しているので必要に応じて追加)
  const x1 = Math.min(startX, endX);
  const y1 = Math.min(startY, endY);
  const w  = Math.abs(endX - startX);
  const h  = Math.abs(endY - startY);
  if (w<1 || h<1) return;

  // 1) 選択範囲を小さく描画する仮想キャンバスを用意
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width  = Math.max(1, Math.floor(w / mosaicFactor));
  tmpCanvas.height = Math.max(1, Math.floor(h / mosaicFactor));
  const tctx = tmpCanvas.getContext('2d');

  // 2) 選択範囲を縮小して描画
  tctx.drawImage(canvas,
    x1, y1, w, h,  // 元の範囲
    0, 0, tmpCanvas.width, tmpCanvas.height // 縮小先
  );

  // 3) その小さくなった画像を、元サイズに拡大して描画
  ctx.drawImage(
    tmpCanvas,
    0, 0, tmpCanvas.width, tmpCanvas.height, // 縮小画像
    x1, y1, w, h // 元キャンバス位置に拡大描画
  );
});

// --------------------------------------------------
// 6) トリミング処理
// --------------------------------------------------
applyTrimBtn.addEventListener('click', () => {
  if (!isImageLoaded) return;
  if (startX===undefined || endX===undefined) return;

  // Undo保存
  pushHistory();

  const x1 = Math.min(startX, endX);
  const y1 = Math.min(startY, endY);
  const w  = Math.abs(endX - startX);
  const h  = Math.abs(endY - startY);
  if (w<1 || h<1) return;

  // 選択範囲を取得
  const trimmedImage = ctx.getImageData(x1, y1, w, h);

  // キャンバスをトリミング後サイズに
  canvas.width = w;
  canvas.height= h;
  ctx.putImageData(trimmedImage, 0, 0);

  // 選択範囲リセット
  startX = startY = endX = endY = undefined;
});

// --------------------------------------------------
// 7) ダウンロード処理
// --------------------------------------------------
downloadBtn.addEventListener('click', () => {
  if (!isImageLoaded) return;
  // 赤枠など余計な描画をしていない場合は、単にダウンロードOK
  const link = document.createElement('a');
  link.download = 'edited-image.png';
  link.href = canvas.toDataURL();
  link.click();
});

// --------------------------------------------------
// 8) Undo処理
// --------------------------------------------------
undoBtn.addEventListener('click', () => {
  if (historyStack.length === 0) return;
  const snap = historyStack.pop();
  canvas.width = snap.width;
  canvas.height= snap.height;
  ctx.putImageData(snap.data, 0, 0);

  // 選択範囲リセット
  startX = startY = endX = endY = undefined;
});

// --------------------------------------------------
// 9) リセット処理 (オリジナルに戻す)
// --------------------------------------------------
resetBtn.addEventListener('click', () => {
  if (!originalImageData) return;
  canvas.width = originalWidth;
  canvas.height= originalHeight;
  ctx.putImageData(originalImageData, 0, 0);

  // 履歴クリア
  historyStack = [];
  // 選択範囲リセット
  startX = startY = endX = endY = undefined;
});
</script>
</body>
</html>
