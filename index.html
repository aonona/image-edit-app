<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ダウンスケールモザイク+トリミング+Undo+リセット+DL (赤枠対策)</title>
  <style>
    canvas {
      border: 1px solid black;
      touch-action: none; /* スマホでもドラッグ操作 */
      cursor: crosshair;
    }
    #controls {
      margin-top: 10px;
    }
  </style>
</head>
<body>
<h1>ダウンスケール方式モザイク+トリミング+Undo+リセット+DL (赤枠が多重化しない版)</h1>

<input type="file" id="upload" accept="image/*"><br><br>
<canvas id="canvas"></canvas>

<div id="controls">
  <button id="applyMosaic">モザイク</button>
  <button id="applyTrim">トリミング</button>
  <button id="downloadBtn">ダウンロード</button>
  <button id="undoBtn">一つ戻る</button>
  <button id="resetBtn">リセット</button>
</div>

<script>
/* --------------------------------------------------
   1) 要素・変数の定義
-------------------------------------------------- */
const uploadInput = document.getElementById('upload');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const applyMosaicBtn = document.getElementById('applyMosaic');
const applyTrimBtn   = document.getElementById('applyTrim');
const downloadBtn    = document.getElementById('downloadBtn');
const undoBtn        = document.getElementById('undoBtn');
const resetBtn       = document.getElementById('resetBtn');

let img = new Image();
let isImageLoaded = false;

// 選択範囲
let startX, startY, endX, endY;
let isSelecting = false;

// ダウンスケールモザイクの“粗さ”
// 大きいほど荒い (10→幅高さ1/10に縮小→10倍拡大)
let mosaicFactor = 10;

/*
  Undo用の履歴スタック:
   - canvasの幅・高さ・ImageData全部を保存
*/
let historyStack = [];

// リセット用
let originalWidth  = 0;
let originalHeight = 0;
let originalImageData = null;

// “現在のキャンバス状態”を常に保持して
// 枠を描くときにその状態へ戻せるようにする
let editedImageData = null;

/* --------------------------------------------------
   2) 画像アップロード
-------------------------------------------------- */
uploadInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = ev => {
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      isImageLoaded = true;

      // リセット用に初期状態を保存
      originalWidth  = img.width;
      originalHeight = img.height;
      originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // “現在の編集後状態”を更新
      editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // 履歴スタックをクリア
      historyStack = [];
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

/* --------------------------------------------------
   3) Pointer Events - 範囲選択
-------------------------------------------------- */
canvas.addEventListener('pointerdown', e => {
  if (!isImageLoaded) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height/ rect.height;

  startX = (e.clientX - rect.left)*scaleX;
  startY = (e.clientY - rect.top )*scaleY;
  isSelecting = true;
});

canvas.addEventListener('pointermove', e => {
  if (!isSelecting) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height/ rect.height;

  endX = (e.clientX - rect.left)*scaleX;
  endY = (e.clientY - rect.top )*scaleY;
  drawSelection();
});

canvas.addEventListener('pointerup', e => {
  if (!isSelecting) return;

  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height/ rect.height;

  endX = (e.clientX - rect.left)*scaleX;
  endY = (e.clientY - rect.top )*scaleY;
  isSelecting = false;
  drawSelection();
});

canvas.addEventListener('pointercancel', () => {
  isSelecting = false;
});

/* 
  毎回 “editedImageData” を putImageData して
  いったん赤枠なしの状態に戻してから strokeRect 
*/
function drawSelection(){
  if (!isImageLoaded) return;
  if (!editedImageData) return;

  // 1) 現在のキャンバス状態を “editedImageData” から復元
  ctx.putImageData(editedImageData, 0, 0);

  if (startX===undefined || endX===undefined) return;

  // 2) 赤枠だけ strokeRect
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  ctx.strokeRect(
    startX, startY,
    (endX - startX),
    (endY - startY)
  );
}

/* --------------------------------------------------
   4) Undo用に現在のCanvasを保存
-------------------------------------------------- */
function pushHistory(){
  const snap = {
    width: canvas.width,
    height: canvas.height,
    data: ctx.getImageData(0,0, canvas.width, canvas.height)
  };
  historyStack.push(snap);
}

/* --------------------------------------------------
   5) モザイク処理 (ダウンスケール→アップスケール)
-------------------------------------------------- */
applyMosaicBtn.addEventListener('click', () => {
  if (!isImageLoaded) return;
  if (startX===undefined || endX===undefined) return;

  // Undo保存
  pushHistory();

  // 選択範囲
  const x1 = Math.min(startX, endX);
  const y1 = Math.min(startY, endY);
  const w  = Math.abs(endX - startX);
  const h  = Math.abs(endY - startY);
  if (w<1 || h<1) return;

  // 1) 小さく描画する仮想Canvas
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width  = Math.max(1, Math.floor(w / mosaicFactor));
  tmpCanvas.height = Math.max(1, Math.floor(h / mosaicFactor));
  const tctx = tmpCanvas.getContext('2d');

  // 2) 選択範囲を縮小描画
  tctx.drawImage(canvas, x1, y1, w, h, 0, 0, tmpCanvas.width, tmpCanvas.height);

  // 3) それを元のサイズに拡大描画
  ctx.drawImage(tmpCanvas, 0,0, tmpCanvas.width, tmpCanvas.height, x1, y1, w, h);

  // 4) “編集後の状態”を取り直す
  editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
});

/* --------------------------------------------------
   6) トリミング
-------------------------------------------------- */
applyTrimBtn.addEventListener('click', () => {
  if (!isImageLoaded) return;
  if (startX===undefined || endX===undefined) return;

  // Undo保存
  pushHistory();

  const x1 = Math.min(startX, endX);
  const y1 = Math.min(startY, endY);
  const w  = Math.abs(endX - startX);
  const h  = Math.abs(endY - startY);
  if (w<1 || h<1) return;

  // 選択範囲を抜き出してCanvasリサイズ
  const trimmed = ctx.getImageData(x1, y1, w, h);
  canvas.width = w;
  canvas.height= h;
  ctx.putImageData(trimmed, 0, 0);

  // 新たに“編集後の状態”を保存
  editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // 選択リセット
  startX = startY = endX = endY = undefined;
});

/* --------------------------------------------------
   7) ダウンロード
-------------------------------------------------- */
downloadBtn.addEventListener('click', () => {
  if (!isImageLoaded) return;
  // 赤枠などは“実際のCanvasには描いてない”からそのままDLOK
  const link = document.createElement('a');
  link.download = 'edited-image.png';
  link.href = canvas.toDataURL();
  link.click();
});

/* --------------------------------------------------
   8) 一つ戻る (Undo)
-------------------------------------------------- */
undoBtn.addEventListener('click', () => {
  if (historyStack.length===0) return;
  const snap = historyStack.pop();
  canvas.width = snap.width;
  canvas.height= snap.height;
  ctx.putImageData(snap.data, 0, 0);

  // “編集後の状態”も戻す
  editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // 選択リセット
  startX = startY = endX = endY = undefined;
});

/* --------------------------------------------------
   9) リセット
-------------------------------------------------- */
resetBtn.addEventListener('click', () => {
  if (!originalImageData) return;
  canvas.width = originalWidth;
  canvas.height= originalHeight;
  ctx.putImageData(originalImageData, 0, 0);

  // “編集後の状態”を戻す
  editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // 履歴クリア
  historyStack = [];

  // 選択リセット
  startX = startY = endX = endY = undefined;
});
</script>
</body>
</html>
