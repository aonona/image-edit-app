<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像編集アプリ v2.2</title>
    <style>
        canvas {
            border: 1px solid black;
            /* スマホやタブレットのスワイプ動作を防止して、自由にドラッグ操作できるようにする */
            touch-action: none;
            cursor: crosshair;
        }
        #controls {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>画像編集アプリ v2.2</h1>
    <!-- 画像をアップロード -->
    <input type="file" id="upload" accept="image/*">
    <br><br>
    
    <!-- 画像を描画するキャンバス -->
    <canvas id="canvas"></canvas>
    <div id="controls">
        <button id="applyMosaic">モザイク処理</button>
        <button id="applyTrim">トリミング</button>
        <button id="downloadImage">ダウンロード</button>
        <button id="undoButton">一個前に戻る</button>
        <button id="resetButton">リセット</button>
    </div>

    <script>
        // 各要素の取得
        const uploadInput = document.getElementById('upload');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const applyMosaicBtn = document.getElementById('applyMosaic');
        const applyTrimBtn = document.getElementById('applyTrim');
        const downloadImageBtn = document.getElementById('downloadImage');
        const undoButton = document.getElementById('undoButton');
        const resetButton = document.getElementById('resetButton');

        // 画像読み込み関連
        let img = new Image();
        let isImageLoaded = false;

        // 選択範囲関係
        let startX, startY, endX, endY;
        let isSelecting = false;

        // 「最新の編集後の状態」を常に保持 (赤枠は含まない)
        let editedImageData = null;
        // 「オリジナル状態」のデータ (リセット時に戻すため)
        let originalImageData = null;
        // Undo用の履歴スタック (配列末尾を最新とする)
        let historyStack = [];

        // ---------------------------
        // 画像をアップロードしたときの処理
        // ---------------------------
        uploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                img.onload = function() {
                    // キャンバスのサイズを読み込んだ画像サイズに合わせる
                    canvas.width = img.width;
                    canvas.height = img.height;
                    // 画像を描画
                    ctx.drawImage(img, 0, 0);
                    
                    isImageLoaded = true;
                    
                    // 読み込んだ直後の状態を、
                    //  - editedImageData（現在の編集結果）
                    //  - originalImageData（リセット用）
                    // として両方に保存
                    editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // ヒストリはリセットしておく
                    historyStack = [];
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // ---------------------------
        // Pointer Events (スマホ & PC 両対応)
        // ---------------------------
        canvas.addEventListener('pointerdown', (event) => {
            if (!isImageLoaded) return;
            
            // キャンバス上の座標を計算
            const rect = canvas.getBoundingClientRect();
            startX = event.clientX - rect.left;
            startY = event.clientY - rect.top;
            
            isSelecting = true;
        });

        canvas.addEventListener('pointermove', (event) => {
            if (!isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            endX = event.clientX - rect.left;
            endY = event.clientY - rect.top;
            
            drawSelection(); 
        });

        canvas.addEventListener('pointerup', (event) => {
            if (!isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            endX = event.clientX - rect.left;
            endY = event.clientY - rect.top;
            
            isSelecting = false;
            drawSelection();
        });

        // pointercancel (タッチ操作が中断した場合など)
        canvas.addEventListener('pointercancel', () => {
            isSelecting = false;
        });

        // ---------------------------
        // 赤枠の描画 (キャンバスをeditedImageDataに戻してから枠だけ表示)
        // ---------------------------
        function drawSelection() {
            if (!isImageLoaded) return;

            // まず編集後の画像データを再描画(赤枠が含まれない状態)
            ctx.putImageData(editedImageData, 0, 0);

            // まだ選択範囲が確定していない場合は何も描かない
            if (startX === undefined || startY === undefined || endX === undefined || endY === undefined) {
                return;
            }
            
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, startY, endX - startX, endY - startY);
        }

        // ---------------------------
        // モザイク処理
        // ---------------------------
        applyMosaicBtn.addEventListener('click', () => {
            if (!isImageLoaded || startX === undefined || endX === undefined) return;

            // 今の状態(editedImageData)を履歴にプッシュ (Undo用)
            historyStack.push(editedImageData);

            // 赤枠を一旦消して編集状態に戻す
            ctx.putImageData(editedImageData, 0, 0);

            // キャンバス全体の画像データ取得
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const blockSize = 10; // モザイクブロックサイズ

            // 選択範囲を順にブロック単位で処理
            const startXInt = Math.min(startX, endX);
            const startYInt = Math.min(startY, endY);
            const endXInt = Math.max(startX, endX);
            const endYInt = Math.max(startY, endY);

            for (let y = startYInt; y < endYInt; y += blockSize) {
                for (let x = startXInt; x < endXInt; x += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    for (let dy = 0; dy < blockSize && (y + dy) < endYInt; dy++) {
                        for (let dx = 0; dx < blockSize && (x + dx) < endXInt; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            r += imageData.data[idx];
                            g += imageData.data[idx + 1];
                            b += imageData.data[idx + 2];
                            count++;
                        }
                    }
                    
                    const avgR = Math.floor(r / count);
                    const avgG = Math.floor(g / count);
                    const avgB = Math.floor(b / count);

                    // ブロック単位で平均色を塗りつぶす
                    for (let dy = 0; dy < blockSize && (y + dy) < endYInt; dy++) {
                        for (let dx = 0; dx < blockSize && (x + dx) < endXInt; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            imageData.data[idx] = avgR;
                            imageData.data[idx + 1] = avgG;
                            imageData.data[idx + 2] = avgB;
                        }
                    }
                }
            }
            
            // モザイクの反映結果をキャンバスへ
            ctx.putImageData(imageData, 0, 0);
            // editedImageDataを更新 (赤枠なし状態)
            editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // 必要なら赤枠を再度表示
            drawSelection();
        });

        // ---------------------------
        // トリミング処理
        // ---------------------------
        applyTrimBtn.addEventListener('click', () => {
            if (!isImageLoaded || startX === undefined || startY === undefined ||
                endX === undefined || endY === undefined) {
                return;
            }

            // 現在状態を履歴にプッシュ
            historyStack.push(editedImageData);

            // 赤枠を消して元の画像に戻しておく
            ctx.putImageData(editedImageData, 0, 0);

            // トリミング範囲を計算
            const trimX = Math.min(startX, endX);
            const trimY = Math.min(startY, endY);
            const trimWidth = Math.abs(endX - startX);
            const trimHeight = Math.abs(endY - startY);

            // トリミング領域のイメージデータを取得
            const trimmedData = ctx.getImageData(trimX, trimY, trimWidth, trimHeight);

            // キャンバスサイズを変更して貼り付け
            canvas.width = trimWidth;
            canvas.height = trimHeight;
            ctx.putImageData(trimmedData, 0, 0);

            // editedImageDataを更新
            editedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // 選択範囲はリセット
            startX = startY = endX = endY = undefined;
        });

        // ---------------------------
        // ダウンロード処理
        // ---------------------------
        downloadImageBtn.addEventListener('click', () => {
            if (!isImageLoaded) return;

            // ダウンロード前に赤枠のないeditedImageDataを再描画しておく
            ctx.putImageData(editedImageData, 0, 0);

            // ダウンロード用リンクを作成してクリック
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = canvas.toDataURL();
            link.click();

            // 必要に応じて描画を戻すかどうかはご自由に
            // drawSelection();
        });

        // ---------------------------
        // 一個前に戻す (Undo)
        // ---------------------------
        undoButton.addEventListener('click', () => {
            if (historyStack.length === 0) return; // 履歴がなければ何もしない
            
            // スタックの最後を取り出して、editedImageDataに戻す
            editedImageData = historyStack.pop();
            // キャンバスサイズも復元
            canvas.width = editedImageData.width;
            canvas.height = editedImageData.height;
            
            // キャンバスに再描画
            ctx.putImageData(editedImageData, 0, 0);

            // 選択範囲もリセット (お好みで)
            startX = startY = endX = endY = undefined;
        });

        // ---------------------------
        // リセット処理 (最初に戻す)
        // ---------------------------
        resetButton.addEventListener('click', () => {
            if (!originalImageData) return;

            // originalImageDataに編集結果を戻す
            editedImageData = originalImageData;

            // キャンバスサイズをオリジナルに
            canvas.width = originalImageData.width;
            canvas.height = originalImageData.height;

            // 再描画
            ctx.putImageData(originalImageData, 0, 0);

            // 履歴はクリア
            historyStack = [];

            // 選択範囲リセット
            startX = startY = endX = endY = undefined;
        });
    </script>
</body>
</html>
